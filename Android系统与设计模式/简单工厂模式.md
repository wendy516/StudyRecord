### 简单工厂模式

在谈简单工厂模式之前，咱先看看三种工厂模式有哪些不同；

* 简单工厂模式：根据传入的参数决定实例化哪个对象。
* 工厂模式：工厂模式定义了一个创建对象的接口，由子类进行对象的初始化，即工厂模式将子类的初始化推迟到了子类里。
* 抽象工厂模式：抽象工厂模式和工厂模式很相似，只是它利用接口或者抽象类定义了一个产品族，例如定义一个拨号产品族，只定义功能，不关心实现，具体实现交给Android、ios等操作系统自己完成。

#### 简单工厂模式

定义：

> 根据传入的参数决定实例化哪个对象。

主要角色：

> 工厂：负责实现创建所有实例的内部逻辑，并提供一个外界调用的方法，创建所需的产品对象。
>
> 抽象产品：负责描述产品的公共接口
>
> 具体产品：

简单工厂模式是工厂模式的简化版本，无需定义抽象工厂，通常还可以利用反射来生成对象，简化操作，如下所示：

大家先看下通过反射来实现简单工厂模式：

~~~java
public class SimpleFactory{
    public static <T extends AbstractProduct> getIntance(Class<T> clazz){
        AbstractProduct product = null
        try{
            product = Class.forClass(clazz.getName()).newInstance();
        }catch(Exception exception){//此地为了省事直接捕获Exception ,大家可捕获具体异常
            
        }
        return (T) product;
    }
}
~~~

哈哈~ 简单工厂模式就是这么简单，大家是不是有些懵，莫着急，且待我解释一番~~~

大家会问AbstractProduct是个啥？

> 这个相当于产品的基类，例如：咱们想买一辆奔驰车，咱是不是得选择型号啥啥啥的（原谅我不是一个车迷 为啥我不用其他举例嘞，可能是.....  sick 吧）
>
> 这个时候咱们就可抽出一个AbstractProduct类，该奔驰下的所有车都继承自它，在需要某个型号的车时，把Class类型传给工厂类就可以了

* 优点：创建和使用分离，解耦
* 缺点：违背开闭原则，一单添加新产品就得改工厂类的逻辑，造成工厂逻辑过于复杂。